## OSI七层模型（物 数 网 传 会 表 应）
- 物理层
- 数据层
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img4.png)

### 协议：
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img5.png)
TCP和UDP是运输层的协议，IP是网路层协议
#### TCP连接的三次握手
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img6.png)
- 第一次握手：客户端发送SYN，并且将自己的初始化序列号（ISN）发送给服务端，此时客户端处于 SYN—SEND状态
- 第二次握手：服务器端收到SYN报文后，会发送一个自己的SYN包，自己的初始化序列号，并且会将客户端的ISN+1作为ACK发送给客户端，此时服务器端处于SYN-REVD状态
- 第三次握手：客户端接收到服务器端的SYN包和ACK包后，会把服务器端的序列号+1作为ACK发送给服务器端，表明自己已接收到了服务器端的SYN报文，此时客户端处于一个establish状态


服务端接收到ACK 后也处于establish状态


三次握手的作用是什么？

确保客户端和服务端的发送和能力是否正常，第一次握手，知道服务端知道客服端的发送能力正常的；第二次握手，客户端知道服务端的接收能力和发送能力是正常的，
第三次握手：服务端知道客户端的发送能力和接收能力都是正常的。


初始化序列号（ISN）是固定的吗？


在三次握手过程中，服务端端和客户端会交换ISN，告知对方后续以何种序列进行组装数据，如果ISN是固定的，攻击者就很容易知道后续的确认号，所以ISN不是固定的，是动态生成的。


三次握手过程中，可以携带数据吗？


前面两次握手是不可以携带数据的，如果第一次握手可以携带参数，那么攻击者可能会携带大量的数据进行发送SYN，此时服务端就会花费大量时间和内存来进行处理，如果第一次握手可以携带数据，那么服务器就会更容易受到攻击；
第三次握手是可以携带数据的，因为第三次握手的时候，客户端已经处于establish状态了，确认服务端的发送能力和接收能力是正常的了。


什么是半连接队列？


服务端发送SYN报文时，处理SYN-SEND状态，此时连接是还没有建立的，服务器会把这种状态的请求连接放入到一个队列里面，这种队列叫做半连接队列；已经完成了三次握手的则会放到全连接队列里，如果队列满了，则会发生丢包的现象。

SYN-ACk重传问题？


服务器端发送YN-ACk包后如果过一段时间没有结束到客户端的响应，则会发起重连，如果超出系统设置的重连次数，则服务器会把这个连接从半连接队列中删除，当然每次重连的时间间隔是不一样的，一般是指数增长的，比如间隔1s,2s,4s,8s.....

SYN攻击是什么？


短时间内攻击者伪造大量的IP对服务器进行发送SYN，则服务器需要发送SYN+ACK回复，此时，由于这些伪造的IP并不存在，服务器等不到回应，则需要不断重连直到超时，这样就是大量的占用半连接队列，导致正常的SYN请求因为半连接队列满而被丢弃，导致网络拥挤及瘫痪。


如何检测SYN攻击？


当发现服务器上有大量的半连接请求，并且IP是随机的，基本可以确定这是一次SYN攻击


如何防止SYN攻击？


- 缩短超时时间
- 增加队列连接数量
- 网关过滤

#### 四次挥手
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img7.png)
- 第一次挥手：客户端发送fin报文和序列号seq给服务端，请求关闭连接；此时客户端处于FIN_WAIT1
- 第二次挥手：服务端接收到fin报文和序列号，会把客户端的序列号+1作为ACK，把自己的序列号发送给客户端；此时服务器端处于CLOSE_WAIT状态，客户端收到ACK报文后，客户端处于FIN_WAIT2状态，此时客户端到服务端的连接是释放的，此时处于半连接的状态，客户端不会再发送消息，但是可以接受消息；
- 第三次挥手：服务端发送fin报文和序列号seq给客户端，请求关闭连接；此时服务端处于LAST_ACK状态，等待客户端的回应
- 第四挥手：客户端接收到fin报文和序列号后，会以序列号+1作为ACK发送给服务端，此时客户端处于TIME_WAIT状态；服务端接收到响应后处于CLOSE状态；


此时客户端处于TIME_WAIT状态会等到服务端确认接收到响应后关闭后才会关闭当前连接；如果服务端没有收到响应，会再次执行第三次挥手的步骤，客服端再次响应；所以客户端处于TIME_WAIT状态等待的时长是两个2MSL，MSL是最长报文段寿命，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。两个MSL就是一来一回的时间。


为什么挥手需要四次？


因为TCP是半关闭模式造成的。半关闭就是一方发起连接释放请求后，是不再发送信息，但是可以接受信息


为什么TIME_WAIT等待时长是两个2MSL呢？


理论上执行完4次挥手后就可以进入CLOSE状态了，但是有可能因为网络的原因，导致丢包，需要等待服务器重新发送FIN报文，然后客户端再次发送ACK确认，这样一来一回就是2MSL。


#### 什么是TCP拥塞控制？https://www.iamshuaidi.com/1913.html


TCP拥塞控制是为了解决网络拥堵而提出来的措施。


为什么要进行拥塞控制呢？


我们知道，TCP在三次握手后就可以进行数据的传递了，但是我们并不是网络的拥堵情况，我们不知道一次需要发送多少个数据包合适而不会造成网络拥堵和数据丢包？定义一次发送多少个数据包叫做拥塞窗口（N表示）


比如，主机A向服务端发送数据时，迟迟得不到ACK响应，以为是数据丢包了，而有可能是因为网络拥堵，导致数据被堵在了半路，而此时主机A以为丢包了，则会重传数据包，导致网络拥堵更严重了，所以提出了拥塞控制


如何探测网络拥堵情况呢？


方法：先发送一个数据包，如果是数据包没有超时，则第二次发送2个数据包，依次类推，每次增加1 N= 1，2，3，4，5


这种方法太慢， 可以指数增加，N = 1，2，4，8，16 这种方法叫指数增长，不管是依次增长，还是指数增长，总会达到瓶颈值，第一种方法增加过慢，第二种方法增加过快，一下子就达到了瓶颈值；


为了解决过慢或者过快的问题，可以两个方法结合起来，找到一个阀值，阀值前指数增长，阀值后，线性增长，这个阀值可以用个ssthresh来表示


最终的策略是：前期指数增长，过了阀值后，线性增加；指数增长阶段叫做慢启动，线性增长阶段叫做拥塞避免


到达了瓶颈值之后怎么做呢？


比如阀值ssthresh =8;到达了瓶颈值之后14，那么会让N= 1；并且把阀值ssthresh = max/2 = 14/2 = 7;


超时一定是网络拥堵吗？


超时不一定是因为网络拥堵，有可能是因为数据丢包或者数据损坏导致超时，那如何解决数据丢包问题呢？


比如，主机A发送数据是用一定的顺序的，M1,M2,M3，M4,M5 服务器在接收数据时，发现M3没有接收到，说明M3丢包了，服务器会采用冗余ACK的方式，就是会连续发送3次M2的确认信息给主机A，那么主机A收到3次M2的确认信息后，就知道M3丢包了，那么就不会等到M3超时发生，就会立马重新发送M3数据包，此时会将N设置为ssthresh，N在一个一个线性递增；这个方法叫做拥塞TCP Reno，这种情况叫做快速恢复


还有另外一种情况，N会重新设置为1，这种叫做TCP Tahoe









