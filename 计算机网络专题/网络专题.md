## OSI七层模型（物 数 网 传 会 表 应）
- 物理层
- 数据层
- 网络层
- 传输层
- 会话层
- 表示层
- 应用层
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img4.png)

### 协议：
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img5.png)
TCP和UDP是运输层的协议，IP是网路层协议
#### TCP连接的三次握手
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img6.png)
- 第一次握手：客户端发送SYN，并且将自己的初始化序列号（ISN）发送给服务端，此时客户端处于 SYN—SEND状态
- 第二次握手：服务器端收到SYN报文后，会发送一个自己的SYN包，自己的初始化序列号，并且会将客户端的ISN+1作为ACK发送给客户端，此时服务器端处于SYN-REVD状态
- 第三次握手：客户端接收到服务器端的SYN包和ACK包后，会把服务器端的序列号+1作为ACK发送给服务器端，表明自己已接收到了服务器端的SYN报文，此时客户端处于一个establish状态


服务端接收到ACK 后也处于establish状态


三次握手的作用是什么？

确保客户端和服务端的发送和能力是否正常，第一次握手，知道服务端知道客服端的发送能力正常的；第二次握手，客户端知道服务端的接收能力和发送能力是正常的，
第三次握手：服务端知道客户端的发送能力和接收能力都是正常的。


初始化序列号（ISN）是固定的吗？


在三次握手过程中，服务端端和客户端会交换ISN，告知对方后续以何种序列进行组装数据，如果ISN是固定的，攻击者就很容易知道后续的确认号，所以ISN不是固定的，是动态生成的。


三次握手过程中，可以携带数据吗？


前面两次握手是不可以携带数据的，如果第一次握手可以携带参数，那么攻击者可能会携带大量的数据进行发送SYN，此时服务端就会花费大量时间和内存来进行处理，如果第一次握手可以携带数据，那么服务器就会更容易受到攻击；
第三次握手是可以携带数据的，因为第三次握手的时候，客户端已经处于establish状态了，确认服务端的发送能力和接收能力是正常的了。


什么是半连接队列？


服务端发送SYN报文时，处理SYN-SEND状态，此时连接是还没有建立的，服务器会把这种状态的请求连接放入到一个队列里面，这种队列叫做半连接队列；已经完成了三次握手的则会放到全连接队列里，如果队列满了，则会发生丢包的现象。

SYN-ACk重传问题？


服务器端发送YN-ACk包后如果过一段时间没有结束到客户端的响应，则会发起重连，如果超出系统设置的重连次数，则服务器会把这个连接从半连接队列中删除，当然每次重连的时间间隔是不一样的，一般是指数增长的，比如间隔1s,2s,4s,8s.....

SYN攻击是什么？


短时间内攻击者伪造大量的IP对服务器进行发送SYN，则服务器需要发送SYN+ACK回复，此时，由于这些伪造的IP并不存在，服务器等不到回应，则需要不断重连直到超时，这样就是大量的占用半连接队列，导致正常的SYN请求因为半连接队列满而被丢弃，导致网络拥挤及瘫痪。


如何检测SYN攻击？


当发现服务器上有大量的半连接请求，并且IP是随机的，基本可以确定这是一次SYN攻击


如何防止SYN攻击？


- 缩短超时时间
- 增加队列连接数量
- 网关过滤

#### 四次挥手
![avatar](https://github.com/liangshuangs/vue-study/blob/main/img/img7.png)
- 第一次挥手：客户端发送fin报文和序列号seq给服务端，请求关闭连接；此时客户端处于FIN_WAIT1
- 第二次挥手：服务端接收到fin报文和序列号，会把客户端的序列号+1作为ACK，把自己的序列号发送给客户端；此时服务器端处于CLOSE_WAIT状态，客户端收到ACK报文后，客户端处于FIN_WAIT2状态，此时客户端到服务端的连接是释放的，此时处于半连接的状态，客户端不会再发送消息，但是可以接受消息；
- 第三次挥手：服务端发送fin报文和序列号seq给客户端，请求关闭连接；此时服务端处于LAST_ACK状态，等待客户端的回应
- 第四挥手：客户端接收到fin报文和序列号后，会以序列号+1作为ACK发送给服务端，此时客户端处于TIME_WAIT状态；服务端接收到响应后处于CLOSE状态；


此时客户端处于TIME_WAIT状态会等到服务端确认接收到响应后关闭后才会关闭当前连接；如果服务端没有收到响应，会再次执行第三次挥手的步骤，客服端再次响应；所以客户端处于TIME_WAIT状态等待的时长是两个2MSL，MSL是最长报文段寿命，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。两个MSL就是一来一回的时间。


为什么挥手需要四次？


因为TCP是半关闭模式造成的。半关闭就是一方发起连接释放请求后，是不再发送信息，但是可以接受信息


